# 程序运行时的内存

从前面的章节我们可以了解到，程序在运行时，需要先将程序装载到内存中才能被执行。

### 1. 程序的内存布局

我们以32位的操作系统为例，在32位的操作系统中，这个内存空间具有4GB的寻址能力，当程序可以直接通过32位的地址进行寻址，这种内存模型称为平台的内存模型，即用户可以通过一个32位的指针访问内存中的任意位置。

尽管现代的内存模型时平坦的，但是不同的地址区间具有不同的地位。Windows将高地址的2GB留给系统内核使用，Linux将高地址的1GB留给内核使用，留给系统内核使用的内存程序是不能进行访问的。

剩下的2GB/3GB的空间称为用户空间，在用户空间中，许多地址空间有特殊的地位，一般来讲，应用程序的空间里有如下的“默认区域”：

+ 栈： 栈通常位于最高地址处分配，通常有数兆字节的大小。栈的作用是维护函数调用的上下文，离开了栈，函数调用就无法进行。
+ 堆： 堆通常为栈的下方，堆比栈要大得多。堆的作用是容纳程序动态分配的内存区域。
+ 可执行文件映像： 这里存储着可执行文件在内存中的映像。
+ 保留区： 保留区不是一个单独的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。

![](.\images\Linux下的内存布局.png)

上图中有一个叫做`dynamic libraries`的区域，这个区域称为动态链接库映射区，这个区用于映射装载的动态库，在Linux中，如果可执行文件依赖动态库，那么系统就会从`0x4000000`的位置分配内存空间。

图中的箭头标明了几个大小可变的区的增长方向，这里可以清楚的看到栈向低地址增长，堆向高地址增长。当预分配的内存地址不足时，他们就会按照图中的方向扩张自己的内存，直到预留的内存用完为止。

### 2. 栈与调用惯例

#### 2.1 什么是栈

栈是现代计算程序中最重要的概念之一，几乎每个程序都用到了栈，没有栈就没有函数和局部变量。

经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出的操作使得栈顶的位置增大。

栈在程序运行中具有举足轻重的地位，因为栈保存了函数调用所维护的信息。这常常被称为堆栈帧或活动记录。堆栈帧一般包括以下几方面的内容：

+ 函数的返回地址和参数。
+ 临时变量：函数的局部非静态变量和编译器自动生成的局部变量。
+ 保存的上下文：包括在函数执行前后需要保持不变的寄存器。

在i386中，函数的活动记录的范围使用`ebp`和`esp`两个寄存器记录，`esp`始终指向栈顶，`ebp`指向函数活动中一个固定的位置。

![](.\images\函数活动记录.png)

`esp`指向栈顶，因此随着函数的执行，不断地有局部变量被压入栈中，因此`esp`会不断地变化，而`ebp`不会变换，`ebp`之前存储函数地返回地址，再往前是函数地参数，因此当函数返回地时候，可以直接读取`ebp`寄存器中地值，即可获取函数地返回地址。

函数的活动记录和编译生成的函数调用的汇编代码有着密切的联系。一个函数总是这样调用的：

+ 将函数调用的参数压入栈
+ 将当前函数调用指令的下一条指令的地址压入栈
+ 跳转到函数体执行

#### 2.2 函数的调用惯例

+ 函数调用的传递顺序和方式
+ 栈的维护方式

![](.\images\函数调用栈.png)

### 3. 堆

堆的作用就是用来动态分配内存，动态分配的内存在不使用时需要进行释放。