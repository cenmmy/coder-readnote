# 编译器做了什么？

![](.\images\编译过程.png)

上面的这张图展示了编译做的所有的工作：

+ 首先源代码经过词法扫描器生成`Tokens`
+ `Tokens`经过语法解析器生成`语法树`
+ `语法树`经过语义解析器生成有类型注释的`语法树`
+ `类型注释的语法树`经过源代码优化器生成`优化后的中间代码`
+ `优化后的中间代码`经过代码生成器产生针对不同平台的`目标代码`
+ `目标代码`经过代码优化器生成`最终目标代码`

下面以一段简单的代码来分析编译对其进行处理的整个过程。

```c++
array[index] = (index + 4) * (2 + 6)
```

### 1. 词法分析

词法分析器经过有限状态机算法将源代码的字符序列分割成一系列的记号。例如上面的代码经过词法分析之后生成的记号有：

| 记号  |    类型    |
| :---: | :--------: |
| array |   标识符   |
|   [   |  左方括号  |
| index |   标识符   |
|   ]   |  右方括号  |
|   =   | 赋值运算符 |
|   (   |  左圆括号  |
| index |   标识符   |
|   +   |    加号    |
|  ...  |    ...     |

### 2. 语法分析

通过语法分析器将`Tokens`生成以表达式为节点的`语法树`。

![](.\images\语法树.png)

### 3. 语义分析

编译器进行的语义分析是静态语义分析，静态语义分析通常包括声明和类型的匹配，类型的转换。经过语义分析阶段之后，整个语法树的节点都被标识了类型，如果某些类型还需要进行类型转换，语义分析程序还会在语法树中插入相应的转换节点。

![](.\images\语义分析后的语法树.png)

### 4. 中间代码生成

通常编译器会对我们写的代码进行优化，直接在语法树上进行优化不方便，因此需要转换为更加适合进行优化的中间代码。

将语法树转换为中间代码

```txt
t1 = 2 + 6
t2 = index * 4
t3 = t1 * t2
array[index] = t3
```

对中间代码进行优化

```txt
// t1 = 2 + 6 可以优化为8
t2 = index * 4
t2 = t2 * 8
array[index] = t2
```

由于中间代码及其之前的操作是与平台无关的，之后的操作是与平台相关的，因此中间代码生成及其之前的操作可以设计成为编译器前端，之后的部分设计为编译器后端，一个编译器前端对应多个编译器后端，从而实现编译器的跨平台。

### 5. 目标代码生成与优化

代码生成器将中间代码转换为目标代码

![](.\images\目标代码生成.png)

目标代码优化，如使用位移代替乘法，删除多余的指令等

![](.\images\目标代码优化.png)

到这里编译器就完成了它所有的工作，但是注意，此时index和array的地址还没有确定，如果index和array和上面的源代码中在同一个编译单元中，那么编译器可以为index和array分配空间，确定它们的地址，但是如果定义在不同的编译单元中，则需要通过链接才能确定其地址。

因此现代编译器可以将一个源代码编译成一个未链接的目标文件，然后最终将这些目标文件链接起来生成可执行文件。