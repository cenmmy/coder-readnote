# 链接器做了什么

### 1. 为什么需要链接器

在计算机发展的早期，人们通过在纸带上打孔来编写程序，如下：

![](.\images\纸带打孔编写程序.png)

每条指令占8位，跳转指令的高四位为`0001`，低四位表示跳转的地址。上面的指令中，第一条指令就是一条跳转指令，跳转的地址是第五条指令，即下标为4的指令处。当程序发生改变时，假设我们在第五条指令之前添加了一条新的指令，则第一条跳转的指令变成了跳转到第六条指令处，即：

```txt
0 0001 0101
1 ...
2 ...
3 ...
4 ...
5 1000 0111
6 ...
```

可以看到当我们修改了代码之后，需要手动计算跳转指令跳转的位置，这个过程称为重定位。

这样一条指令还好，当程序变得庞大时，可能会存在成百上千条指令，最坏的情况下，我们需要重新手动计算所有的目标地址，这个过程非常繁琐且耗时。

后来人们实在忍无可忍，于是引入了汇编器，汇编器提出了符号的概念，我们可以在编码的时候，将跳转地址使用符号进行代替，而汇编器会在翻译成机器码的时候，自动计算出符号的真实地址，并将对应的符号跳转称为该地址。

后来随着软件规模的扩大，程序被分割成多个模块，模块之间的通信方式有两种，一种是函数调用，一种是变量。这两种方式都可以归结为一种方式，那就是模块间的符号的引用。下图形象地表示了链接地过程：

![](.\images\模块间拼接.png)

### 2. 静态链接做了什么

链接：人们把每个源代码模块独立地编译，然后按照需要将他们组装在一起，这个组装模块的过程就称为链接。

从原理上讲，链接过程重要包括了地址和空间分配，符号决议和重定位。

最基本的链接过程如下图所示：

![](\images\静态链接过程.png)

首先源文件即每个编译单元分别被编译器编译成为目标文件，然后项目中所有的目标文件和运行时库被链接器链接称为可执行文件。

下面的例子展示了不同编译单元之间通过函数调用进行通讯的实例。

![](\images\静态链接实例.jpg)

当func.c被修改并重新编译之后，在链接时，链接器会重新计算foo函数的地址，并将新的地址重定位到main.c中，进行地址修正。

对于变量原理相同。