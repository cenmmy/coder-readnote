# 凡事总有特例

在编写模板代码的过程中，经常会遇到当某些类型作为模板参数的时候需要进行优化，这里就需要创建特例模板。

### 1. 从Vector说起

vector对于C++程序员来说是很常用的`STL`类，它接受一个类型作为参数，当传递的参数为整型或字符串等其他的类型的时候，都没有问题，但是当模板参数类型为`bool`类型的时候，就会出现问题。C++中`bool`类型占用一个字节，而`bool`类型的值只有两种，true或false，其实我们只需要一个bit就可以存储`bool`类型的数据，而不需要一个byte。

因此为了提高性能，`STL`中对vector模板参数为`bool`类型做了特例，即单独实现了这个特例。

```c++
// vector通例
template<typename T>
class vector {
	...
}

// bool时的vector特例
template<>
class vector<bool> {
    ...
}
```

### 2. 特例的多种写法

**匹配式**：模板特例中尖括号修饰的即为匹配式，如<bool>

书写匹配式的几个要求如下：

+ 匹配式卸载模板类名之后，用尖括号括起。
+ 匹配式使用都好分割的项目列表，项目数必须和通例模板参数总数一致。
+ 匹配式中各个项目的类型必须和通例中一致。

下面是几个例子：

```c++
// 通例
template<typename T, int i>
class A {
    ...
}

// 部分特例
template<int i>
class A<char, i> {
    ...
}

// 部分特例
template<typename T>
class A<T, 10> {
    ...
}

// 部分特例
template<typename T, int i>
class A<const T, i> {
    ...
}

// 完全特例
template<>
class A<char, 10> {
    ...
}
```

### 3. 特例匹配原则

同一个模板可以有多个特例，当用户代码提供的模板参数