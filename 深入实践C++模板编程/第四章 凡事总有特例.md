# 凡事总有特例

在编写模板代码的过程中，经常会遇到当某些类型作为模板参数的时候需要进行优化，这里就需要创建特例模板。

### 1. 从Vector说起

vector对于C++程序员来说是很常用的`STL`类，它接受一个类型作为参数，当传递的参数为整型或字符串等其他的类型的时候，都没有问题，但是当模板参数类型为`bool`类型的时候，就会出现问题。C++中`bool`类型占用一个字节，而`bool`类型的值只有两种，true或false，其实我们只需要一个bit就可以存储`bool`类型的数据，而不需要一个byte。

因此为了提高性能，`STL`中对vector模板参数为`bool`类型做了特例，即单独实现了这个特例。

```c++
// vector通例
template<typename T>
class vector {
	...
}

// bool时的vector特例
template<>
class vector<bool> {
    ...
}
```

### 2. 特例的多种写法

**匹配式**：模板特例中尖括号修饰的即为匹配式，如<bool>

书写匹配式的几个要求如下：

+ 匹配式卸载模板类名之后，用尖括号括起。
+ 匹配式使用都好分割的项目列表，项目数必须和通例模板参数总数一致。
+ 匹配式中各个项目的类型必须和通例中一致。

下面是几个例子：

```c++
// 通例
template<typename T, int i>
class A {
    ...
}

// 部分特例
template<int i>
class A<char, i> {
    ...
}

// 部分特例
template<typename T>
class A<T, 10> {
    ...
}

// 部分特例
template<typename T, int i>
class A<const T, i> {
    ...
}

// 完全特例
template<>
class A<char, 10> {
    ...
}
```

### 3. 特例匹配原则

同一个模板可以有多个特例，当用户代码提供的模板参数能够与多个特例进行匹配时，C++的原则简而言之是与最特殊的特例匹配。比较两个特例A和B，如果能够匹配A的模板参数都能匹配B，反之不能成立，那么说明特例A比特例B更加特殊。从集合的概念来看，只有当所有匹配A的参数值组合所构成的集合是所有匹配B的参数值集合的真子集时，才能说A比B更加特殊。

如果不能确定谁更加特殊，那么编译器就会报错。

### 4. 函数模板的特例和重载

函数模板特例的写法与类模板特例的写法相同，也是在函数名之后加上与该特例所匹配的模板参数值即可。

与C语言不同，C++允许函数的重载，重载允许定义多个同名的函数，只要函数的参数不等价即可，以保证编译器能够依据函数参数的个数和参数类型来从多个重名的函数中选取最合适的作为调用函数。函数模板实际上是定义了一组函数，C++标准规定函数模板也可以重载，即可以定义多个同名但不等价的函数模板。

函数重载与特例的相同点在于都是从众多候选的函数中选取最匹配的函数，不同点是函数重载是匹配函数参数，特例是匹配模板参数。但是C++中存在函数模板参数推导机制，当没有显式给定模板参数时，可以通过函数参数的类型推导函数模板参数。

为了解决潜在的冲突和简化问题的处理，C++规定只允许声明完全特例。所谓的完全特例即每个函数参数都需要被指定。

```c++
template<typename T>
void print(T v) {
    ...
}

// 完全特例
template<>
void print<char>(char v) {
    ...
}

// 完全特例，模板参数依赖推导
template<>
void print(const char* v) {
    ...
}

// 函数重载
void print(const std::string& v) {
    ...
}

void print(bool v) {
    ...
}

// 函数模板重载
template<typename T>
void print(T* v) {
    ...
}
```

#### 4.1 分辨重载

```c++
template<typename T>
// 1
void func(T v) {
    ...
}
// 2
template<>
void func(float v) {
    ...
}
// 3
void func(float v) {
    ...
}

int main() {
    func(1);		// 1
    func<>(1.f);	// 2
    func(1.f)		// 3
}
```

编译器分辨重载函数的过程：

1. 发现有同名函数模板时，会根据参数类型依次推导出函数模板参数，如果推导成功，则生成对应的参数作为候选。
2. 发现有重名函数且调用函数名后没有尖括号，也将该函数作为候选，反之不将该函数列入候选。
3. 接下来按照C++标准中对普通重载函数调用分辨重载的规则确定最佳选择

三个准则：

+ 两候选函数如果有一方其形参列表各类型与调用实参列表各类型更匹配，则淘汰令一方。
+ 两候选函数其形参列表类型同等匹配实参列表类型，如果一方为函数模板实例而另一方为非函数模板，则取非模板函数而淘汰函数模板实例。
+ 两候选函数其形参列表类型同等匹配实参列表类型，若两者均为函数模板实例，则取更为特殊的一方而淘汰另一方。

#### 4.2 编译期的条件判断逻辑

```c++
template<int i>
void print() {
    print<i - 1>();
    std::cout << i << std::endl;
}

// 特例
template<>
void print<1>() {
    std::cout << 1 << std::endl;
}

int main() {
    print<100>();
}
```





