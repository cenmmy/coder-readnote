# Hello 模板！

### 1. 为什么需要模板

当代码逻辑与参数类型无关时，为了避免为将要用到的所有的参数类型实现其函数或类，可以通过使用模板来指导编译器在编译期生成相应的函数模板或类模板实例。

### 2. 基本用法

```C++
template <typename T>
T func(T t1) {
    ...
}

int main() {
    func<int>(1);
}
```

### 3. 模板参数自动推导

+ 编译器只根据函数调用时提供的实参来推导模板参数，与函数参数无关的模板参数其实际的类型无法推导
+ 与函数返回值相关的模板参数无法推导
+ 所有可推导的模板参数必须连续位于模板参数列表的尾部，中间不能有不可推导的模板参数

例：

```c++
// 模板参数中只有T1和T3与参数相关，因此只有这两个模板参数可以根据实参进行推导
// T0是返回值类型，因此不能根据实参进行推导，必须在函数调用时进行指定
// T1和T3之间的T2是不可推导的，因为其与参数列表无关，但是根据规则3，T1必须在函数调用时指定其参数，即使T1的实际类型可以推导出来
template <typename T0, typename T1, typename T2, typename T3>
T0 func(T1 t1, T3 t3) {
    T2 t2;
    ...
}

int main() {
    func<int, int, double>(1, 2);
}
```

### 4. 模板从参数默认值

可以为不可以进行参数推导的模板参数指定默认值

```c++
template <typename T0 = int, typename T1, typename T2 = double, typename T3>
T0 func(T1 t1, T3 t3) {
    T2 t2;
    ...
}
```

### 5. 模板函数的定义和声明需在同一个头文件中

假设函数模板的定义和声明不在同一个头文件中，而是声明放在头文件中，定义放在cpp文件中，例如：

```c++
// template_func.hpp
template <typename T>
void func(T t);
```

```c++
// template_func.cpp
#include <tempalte_func.hpp>
template <typename T>
void func(T t) {
    ...
}
```

```c++
//main.cpp
#include <template_func.hpp>

int main() {
    func(1);
    return 0;
}
```

首先预编译器会将头文件的内容拷贝到每个C++文件中，然后将每个C++文件分别编译成.o文件，在编译main.cpp的时候，由于找不到模板定义，编译器此时无法为其创建相应的模板实例，因此会生成一个调用链接，而在template_func.cpp中，由于没有调用函数模板，因此编译器就不会为其创建模板实例，因此在链接时，链接器会因为找不到func<int>的定义而报错。

将函数模板的声明和定义都放在头文件中，编译器在编译main.cpp时就会生成相应的模板实例。

### 6. 重复模板

将模板的声明和实现都放在头文件中，解决了编译时无法编译器无法创建相应的函数模板实例而导致链接时报错的情况，但是如果两个cpp文件中都调用了`func<int>(1)`，编译器就会在编译这两个源文件的时候分别创建模板实例，这样就会导致重复模板。

C++标准的规定对重复的模板进行合并，即保留其中一个，具体保留哪个是随机的。

C++标准规定相同的函数签名即认为函数模板是重复的，不考虑其函数体的具体实现。

解决方法是使用命名空间。

