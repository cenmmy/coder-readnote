# 代码膨胀

模板的另外一个缺点就是带来代码膨胀，代码膨胀分为两种情况，一种是源代码的增加，一种是目标代码尺寸的增加。

### 1. 源代码的增加

源代码增加的主要原因是模板特例导致的，再前面的章节中，我们提到为了应对真实的需求，有时我们需要对特定的类型提供模板特例，比如`vector`为`bool`类型提供了特例。

但是C++的模板特例机制有很大的局限性，那就是特例必须以完整的类或函数为单位整体生成。对于模板特例仅需要对模板的小部分代码进行微调的情况，就会生成重复的代码。

源代码增加的解决方案是再编译时进行类型判断。

如：

```c++
static if (is_const == false)
```

但是C++11标准还没有提供类似的语法。

### 2. 目标代码的增加

目标代码增加的原因有两个：

+ 模板实例再多个目标文件中重复存在。
+ 模板机制导致的大量类型及相关模板函数实例的出现。

对于原因1，链接器再链接时会根据优先级来删除重复的函数模板。

对于原因2，我们可以对与模板参数无关的函数提取到基类中，以避免产生大量重复的函数模板实例。

如：

```c++
template <typename T>
class A {
    int a;
public:
    void func1();
    void func2(T arg1);
};
```

对于函数`func1`来说，其与模板参数无关，因此可以提升到基类中，避免在实例化时实例该函数，产生目标代码重复。

```c++
class Base {
public:
    void func1();
};

template <typename T>
class A: public Base {
    int a;
public:
    void func1();
    void func2(T arg1);
};
```

